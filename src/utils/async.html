<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="boot.html">

<script>
{
  'use strict';

  /**
   * TODOC
   *
   * @namespace
   * @memberof Polymer
   */
  Polymer.Async = {

    /**
     * A timer with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    timeOut: {
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      after(delay) {
        return  {
          run(fn) { setTimeout(fn, delay) },
          cancel: window.setTimeout.bind(window)
        }
      },
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run: window.setTimeout.bind(window),
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel: window.setTimeout.bind(window)
    },

    /**
     * requestAnimationFrame with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    animationFrame: {
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run: window.requestAnimationFrame.bind(window),
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel: window.cancelAnimationFrame.bind(window)
    },

    /**
     * requestIdleCallback with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    idlePeriod: {
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run(fn) {
        return window.requestIdleCallback ?
          window.requestIdleCallback(fn) :
          window.setTimeout(fn, 16);
      },
      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel(timer) {
        return window.cancelIdleCallback ?
          window.cancelIdleCallback(timer) :
          window.clearTimeout(timer);
      }
    },

    /**
     * Micro task with the async interface.
     *
     * TODOC
     *
     * @namespace
     * @memberof Polymer.Async
     */
    microTask: {
      _currVal: 0,
      _lastVal: 0,
      _callbacks: [],
      _twiddleContent: 0,
      _twiddle: document.createTextNode(''),

      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      run(callback) {
        this._twiddle.textContent = this._twiddleContent++;
        this._callbacks.push(callback);
        return this._currVal++;
      },

      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      cancel(handle) {
        const idx = handle - this._lastVal;
        if (idx >= 0) {
          if (!this._callbacks[idx]) {
            throw 'invalid async handle: ' + handle;
          }
          this._callbacks[idx] = null;
        }
      },

      _atEndOfMicrotask() {
        const len = this._callbacks.length;
        for (let i=0; i<len; i++) {
          let cb = this._callbacks[i];
          if (cb) {
            try {
              cb();
            } catch(e) {
              // Clear queue up to this point & start over after throwing
              i++;
              this._callbacks.splice(0, i);
              this._lastVal += i;
              this._twiddle.textContent = this._twiddleContent++;
              throw e;
            }
          }
        }
        this._callbacks.splice(0, len);
        this._lastVal += len;
      },

      /**
       * TODOC
       *
       * @memberof Polymer.Async.timeOut
       */
      flush() {
        this._observer.takeRecords();
        this._atEndOfMicrotask();
      },

      _observer: new window.MutationObserver(function microTaskObserver() {
        Polymer.Async.microTask._atEndOfMicrotask();
      })

    }
  };

  Polymer.Async.microTask._observer.observe(
    Polymer.Async.microTask._twiddle, {characterData: true});

}
</script>
